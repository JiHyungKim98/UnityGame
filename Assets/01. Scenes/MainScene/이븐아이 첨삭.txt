monster attack()에서 p_ 이거 떼어버리기

ontriggerEnter에서 붙는시점에 접촉한 한번의 시점에서 불려서 잘못된 코드임 
몬스터마다 사정거리가 있을테니 코루틴은 코드 순서대로 동작하다 yield를 만나면 그 프레임에 대한 연산이 멈춤. 
해당 초만큼 sleep함. 비동기처럼 굴수있는것이 coroutine임. 
yield return null은 한 프레임을 넘기는 것임
movetotarget()에 while(true)씌워줘야지 몇초간 쫓아가는것이됨.  
update()문에서 1회성 로직이 있으면안됨. 한번만 실행하고 더이상 실행하지 않는 로직이 되어야함. 
unity manual에 들어가서 보는게 제일 정확함.

<과제>
OntriggerEnter는 사용하지 않는게 바람직함. trigger는 검출이 안될수도있음. 
trigger는 움직이지 않는 친구에게 붙이는 것임. player를 상태단위로 나눠서 생각하는게 일반적임. 
캡쳐 확인해보기. 무기달때 손 밑에 empty넣어서 거기밑에 들어가도록함. GameObject.
Find함수는 느려서 잘안씀. 
list같은건 IEnumerable의 형태를 사용(계속 순회할수있는 친구). array보다는 list가 쓸수있는 함수가 훨씬 많음. 
LINQ구문 람다?? 대부분의 경우는 list를 사용하는데 array를 쓰는 경우는 딱 하나있음. 
딱 배열의 크기를 정해놓고 싶을때만 사용. 
Debugging포인트를 보고 확인해봐. monster=GetComponentsInChildren<Monster>().ToList();하면 자동으로 몬스터가 들어감. 
private와 public을 어느때 써야하는지 알아봐두기.  OnTriggerEnter 대신 거리 3이내에 들었을때 동작하도록 거리위주의 로직으로 대체하도록하자. 
rigidbody에서 constrints를 고정보다는 IsKinematic 체크를 하는게 나을수도 잇음
randPos()에서 계속 위치를 바꾸려먼 seed를 생각해봐야함, 그동안 수강했던 수업 정리해서 채널톡에 보내기, 
coroutine 공부 제대로 하기
만약 내꺼 질문하면 stats에서 
전부다 렌더링하고있습니까? 어떻게해서 최적화하고있습니까? 

1. 코루틴에 대해서 공부
2. 유니티 이벤트 함수 순서
3. c# 코드 컨벤션
4.
- Monster ( OnTriggerEnter 로직 제거)
- 상태에 대한 정의를 내리고, 각 상태에 따라 함수가 동작하도록 고민 
- 상태가 변할 때 Debug.Log(현재 상태) 
- 업데이트 문에 있는 함수들 제거
5. 벡터의 내적과 외적의미와 사용 범위









Item 스크립트에서 딜 들어가는 것을 FixedUpdate()에 넣지말고 Attack()라는 함수로 따로 만들어주기 그리고 player스크립트에서
AttackCoroutine()에서 yield를 두개로 쪼개서
그 사이에 item.Attack()로 넣어주는게 좋을듯 디버깅을 넣어서 되는지 테스트하기 
애니메이션 시간보다 attackDelay가 더 긴것같음. (나중에 수정하기 약 0.3초쯤 끝나는것같음) 
animation 탭에서 inspecter보면 length도 적혀있음 잘보기! speed도 세팅할 수 있음.


깃에 대해 설명해주시는 부분
브랜치가 로컬저장소임 원격은 깃허브 저장소임 
변경사항을 커밋하면 로컬 브랜치에 적용됨. push를 하면 변경 사항이 원격에 있는 dev까지 반영됨. 
브랜치를 따서 혼자 작업을하고 완료가되면 merge라는 것을 써서 합치면 dev에 반영이됨. 
push를 하려면 dev 브랜치의 최신 버전을갖고있어야됨==pull을 제일먼저 받아서 작업을 해야됨. 컴파일만 되면 커밋하는것을 추천함.

<과제>
애니메이션이 매끄럽게 돌아가도록 하자. 디버깅 꼭 써주기. 
Item스크립트에서 FindWithTag에서 Enemy가 여러마리 있을경우 문제가 발생할 수 있음 후보군도 따로 저장할수있도록 해야될듯. 
monstercontroller의 리스트에 차례대로 접근하는 스크립트가 나을수도? 로직의 흐름상 흐름도에 어디에 넣을지 생각해봐야함. 
몬스터의 FixedUpdate도 한번실행하는 로직 다른데에 바꾸기. UI쪽으로 만들어보기  



Melle_OneHanded->Idle에서 4초로 되어있어서 안틀리는듯


몬스터 각각 스탯 다르게해서 10종류 등등 아이템 3-4개만 사용하기


몬스터랑 캐릭터 로직을 이번주내에 완성해주기
c#으로 알고리즘 풀기(LINQ를 개념만 공부해오기) 
c# 책도 1월까지 다 읽어보기 이해안되는 개념은 질문주기 다음주까지 12장까지 공부해오기 모르는 부분 정리해서 바로바로 채널톡에 올려주기
최대한 프로퍼티를 사용해서 코딩해보기





















해상도 변경하면 프로필이 자꾸 위치가 바뀜.
Monster.cs 에서 MoveToTarget()함수에서
yield return null;을 넣어줘서 한프레임을 기다려주는 로직이 필요함 여기까지 한프레임이 했고 
그 다음부터는 다음 프레임이 한다는 소리임. 이번 같은 프레임에서 누적이 되어서 문제가 발생한것임.
코루틴은 yield return이 있어야함. 
IEnumberable 한프레임

인터페이스는 추상화의 개념임. 상속받는 클래스는 해당 인터페이스에 적혀있는 함수를 구현해줘야함. abstract class랑 비교해서 공부좀해보기.

트러블 슈팅->안되는거 고쳐본적있느냐라는 질문이 들어오면 이걸 어떤 생각으로 어떻게 해결했다 이런식으로 대답해야됨
최적화가 정말 큰 이슈임


리스트에는 모든 형식을 다 담을수있음.
일반화 프로그래밍: 모든 형식의 타입을 사용할수있게 하는 것. foreach문에 movenext나 ~를 가지고 있는것만 사용됨.

try catch는 실행비용이 비쌈. if랑 다르게 비용이 비쌈. 정말 중요하고 잘 안터지는 곳에서만 써야됨.
LINQ도 객체들에 쓸수있는 것. 형태는 DB Query형태랑 비슷하긴 한데 sort라던지 orderby 라던지 수만은 리스트 속의 데이터를 건드려야되니까
그것을 간단하게 들고오게할수있도록 해주는것. 생산성이랑 가독성이 굉장히 좋아짐.


Func()는 델리게이트 생성자임 T 타입을 리턴하는 Function임






































함수는 다양한 반환값이 있음. 함수 포인터는 함수가 실행될수있는 영역을 가리키는것
함수도  특정타입의 전달인자를 받아서 정해진 타입에 return값을 전해주는 포인터
objectpool 는 delegate랑 제네릭이랑 합쳐진것
즉 T를 반환할수있는함수의 형태를 deletegate로 만들어놓은것
public delete T

invoke()로 해주면 null체크도 하는등의 다양한 장점이 있음 일반저그올 함수를 실행해주는 역할임
Reset()은 필요에따라서 주기적으로 정리해주는 함수.

캡슐화라기 보다는 암튼 캡슐화는 아님 바깥에서 로직 주입을 통해서 만들 수 있음
동영상 플레이어라고 생각하면 어떤 player는 광고를 재생할 수 있음
같은 player지만 영상과 함께 광고를 재생할 수 있는 로직을 넣어줄수있음
delegate를 이용해 특정 타이밍에 로직을 넣어주어 나만의 커스텀을 만들 수 있음.
하나의 클래스를 가지고 입맞에 맞게 다양하게 변경해서 쓸수있음




Canvas UI랑
sprite에서 sorting order가 중요함.
 
sprite는 3d공간이긴 하지만 정확히는 UI는 게임속의 친구들이 아니어서 그것과 상호작용하는게 sprite이고
user들만 만들수있는 최상단의 layer가 UI임, UI는 해상도의 영향을 받음. 그래서 배치할때 고려해야됨.
UI 이미지 해상도는 어떤값을 기준으로 했을때 보이느냐를 말하는 것임. 기준 해상도를 맞춰놓고 보자. anchor도 왼쪽 상단으로 잡아줘야됨.
해상도를 잘 맞춰주자!

canvas가 player안에 있으면 안될듯
지금은 겹치지 않지만 패널 같은거를 띄웠을때 rendering 순서를 결정하는데 문제가 발생할 수 있음. 겹칠때 누가 위에오고 누가 밑에오는지 결정됨.
sorting order가 순서 붙이는 것임. sorting order를 고려해서 작업해야됨. 그려지는 순서로 sorting을 해줘야 UI를 그릴때 혼동이 안오니까 잘 생각하기


Q) 모바일 기기별 해상도 대응(게임을 만들면서 어려웠던 점)
다양한 기기에 맞춰서 해상도를 고려해서 하지 않아서 힘들었다 이런식으로
UI계층으로 분리해서 anchor로 분리했고 canvas로 분리했다 이런식으로 말해도될듯

전체화면 가리는 패널 만들어서 순서를 맞추면서 panel의 sorting order를 고려해보기

UI Manager를 보통 꼭 챙겨감 => 손이 많이 가는 것인데 나중에 UI Mamager를 잘 구성해서 전반적인 룰 뭐가 열리고 뭐가 닫히고를 정리해서
두면 재활용해서 잘 쓸수있지 않았을까 생각해보았습니다. 이런식으로 얘기해도됨.

개발일지 비슷하게 간단하게 정리해놓으면 나중에 면접에가면 좋을듯

함수를 많이 쓰는게 좋음. 읽는 사람에게 쉽게 알려주기 위해서

기술부채(돈 빌렷을때의 그 부채임) 기술이 구멍난 곳이 쌓이면 걷잡을수없이 커짐

Find로 찾지말고 


























람다식은 익명메소드를 사용하기위해 쓰는것. 그렇다면
익명메소드 사용이유? 찾아보니 한번만 사용할대 익명 메소드를 사용
익명메소드가 있는 이유는 거리순으로 정렬한다고 할때 orderby구문 등을 사용해서 더 쉽게 정렬할 수 있고
where구문등을 사용하기 위해서 람다식을 사용함.


익명메소드를 사용하려면 대리자가 항상 있어야되는데 한번쓰고 말것을 위해 대리자를 매번 선언하기 귀찮으니 
Func와 Action대리자를 사용 action 대리자는 반환형식이 없다는 것이 다른데 그럼 보통 어디에 사용을 하는지
callback이라는 것은 하고싶은 행동을 전달했을 때 action을 사용하면 행동을 전달할수있음. callback형태?


별도의 로직을 밖에서 클래스 안으로 주입하고싶을떄 사용가능하다. 쓰임은 무궁무진함.
delegate를 func과 action으로 쓰는 것임.


람다식은 익명함수 기반이어서 익명함수 특성의 일부를 따름. 익명 함수의 특성상 함수 콜 스택 추적이 매우 어렵다는 단점이 있음
익명이어서 함수 자체의 이름만 안보이는 건데 크게 문제는 안됨. 전체 콜스택이 안보일때는 추적이 불가능함.
장점은 코드가 매우 간결해짐
콜스택상에 실행해보면 들어온 순서임. callstack은 로직적으로 함수의 함수의 함수를 타고 움직이는데 그것의 진입순서임
디버깅하면 flow에서 그게 다 보임. 이것을 callstack라고 함.



GetMouseButtonDown(처음에 맨손일때 null일때 
if(MainWeapon에 getchild(0)일때 문제가 생김

bat이 두개일때 문제가 생길수도있으서 인스턴스 이름말고 type으로 해줘야됨
IsNear()함수는 return도 bool로 맞춰주는게 좋음
그래서 이름을 Find어쩌구로 바꾸는게 좋음

플레이어에서 N을 눌렀을때 근처에 있는것을 찾는게 좋을듯. weaponchild에서 fixedupdate에서 말고!

weapon.cs에서 

weaponchild를 weapon이라고 하고 weapon을 weaponcontainer으로 하는게 좋을듯
findwithtag다 지우셈

시리얼라이즈를 통해 인스펙터에 뜨는것임

<방법 두가지>
어딘가에 넣어서 다 들고있는 친구에서 거기서 검색하는 방법



sigleton이 전역변수와 비슷하게 쓸 수 있게 하는 것임. 한개만 쓰는 것이 보장되면 singleton을 써서 사용할 수 있음.
singleton은 인스턴스임. 하나만 생성되게 보장해주는 것.

전역변수는 코드 어디에서도 접근할 수 있는것. 별도의 선언을 하지 않더라도 쓸 수 있는 것. 코드가 안읽히고 관리가 힘듦.
전역변수는 남용/오용의 위험이 많음. 통제가 안되니까.

is와 has의 관계를 생각잘해보자

getchild(0)이렇게 사용하지말기 위험함. 해당 객체의 list을 항상 만들어서 거기서 넣어서 꺼내오도록하자

무기 바꾸기에서 캡쳐본에서 레퍼런스를 바꾸주는 식으로 동작해야됨

click은 =>  OnTouch()로 들어가면될듯?

무기는 많을수록 좋긴한데 type추가 정도인듯.
다 만들고나서 volumn정할때 다시 얘기하자

긴무기는 사정거리 길게, 짧은 무기는 사정거리 짧게, 추가로 공속
모바일용 패드 달아와라!!!!

LINQ까지 공부해서 오렴!~~!! 
다음 수업은2/10




































slot 하나하나에 class를 생성해서 만드는게 좋을듯?
confirmUI가 아닌 곳에서 slot를 쓰니까 slot 클래스를 만들어서 하나하나에 붙여주는게 좋을듯 => 객체 단위로 분리하자
코드는 읽히게 짜는 사람이 코드를 잘쓰는거임

if else문 많이 쓰는것보다 switch문이 더 보기 쉬움. 
public enum Items{
	Gun,
	Paddle,
	MedicBag
}
이런식으로 선언해서

public Sprite SetSprite(Items type){
	swtich(type)
	{
		case Items.Gun:
		break;
		case items.Paddle:
		break;
		case items.MedicBag:
		break;
	}	
}
이런식으로 선언하는게 좋을듯 enum을 쓰면 명시적으로 더 보기쉬움


인스턴스가 쓸수있는 형태로 메모리에 담겨있는 건데
instance를 serilze해서 저장하는 것

scriptableobject는 누군가가 데이터를 요청하면 던져주는 것임

CreateAssetMenu

Serialize를 해줘야 보여진다.
Enum에 넣어놓은것과 연결해주기


게임을 만들다보니 데이터를 찾는 과정이 번거로웠다 근데
scriptableobject로 하나의 데이터 테이블을 만들고 거기서 불러서 사용했더니 좋더라 이런식으로 말하기

main carmera를 root에 붙여놓으면 지금 조이스틱이 vector방향이 반대로 움직임. 그거 수정하기

각자의 역할만 알려주면서 코드를 나누면 될듯

데이터 관리를 linq를 이용해서 관리해서 생산성이 좋았던것 같다.라고 얘기할수도 있을듯
=> 그럼 lamba에 대해서도 설명해보세요라고 이어져서 질문이 이어질수도있음
linq를 써보고 그거에 대한 감상에 대한것을 얘기하면 좋을것같다

설계는 코드로 하는게 아니라 사람의 언어와 사람의 생각으로 해야됨
총을 사람이 갖고있는거지 총을 사람이 갖고있는게 아니니까.
사람이 총을 갖고있냐 인벤토리가 총을 갖고있냐 등의 어떤 관계가 맞는지 구조적으로 말이되고 만들기가 쉬운지가 달려있음.

함수는 행동 클래스는 하나의 사물
클래스의 사물이 이 행동을 하는게 맞는지 확인하면됨.
addtoslot이랑 setsprite는 inventory가 하는 행동이 맞음

ingamecontroller의 mouseon?은 이상함.

총알 종류가 몇개없으니까 container에서 start에서 바로 넣어서 만들어도될듯.

게임잡에서 보면 어떤 역량을 필요로하는지 알수있음




























유니티 공고 위주로 찾아보기
cpu와 gpu가 성능에 영향을 미침

cpu를 사용한다는 것은 앱켜고 cpu 메모리 윙 돌아가는 것보면
cpu사용량이 늘어남. 게임을 기준으로 보면cpu를 사용하는것은 로직부분
gpu를 사용하는 (graphic process unit) 랜더링 애니메이션에 대해서 gpu가 담당함

stats에서 보면 batches /Tris(polygon) 1.1m이면 대충 백만개 /verig 
빌드해서 돌려보면 내 폰에서는 돌아가긴할것같은데 발열이 심할수도
그것을 생각해보면 몬스터가 깔리는 수를 많이 넣을 수 없음.
여기에 나오는 트라이앵글들을 다 그리지 않는 방법도 생각해봐야됨

build settings에 들어가서 usb포트 연결하고 폰은 개발자모드로 켜야됨

Unityhub에서 install에서 플랫폼 다운받아주기

맵이 굉장히 큰데 어떻게 하셨어요? 라고 물어볼수도있음
테크닉적으로 해결해보자
>> 오쿨루전 컬링 /LOD 레벨 오브 디테일(가까이있는 애들은 많은 polygon으로 자세히 보여주고 멀리있는 애들은 덜보이거나 안보이게) 모델링에서 준비가 되어있어야됨

즉, 당장 적용 가능한 것은
안보이는 친구들을 걸러주는것이 오클루전 컬링을 쓸 수 있음

맵을 보면 구획별로 정리되어있는데 
구획별로 나눠서 오브젝트를 아예 끄도록 해도됨. => 이것도 좋은 테크닉임

즉 빌드로 테스트해봐야돼!!
싸이클을 만들고 마지막으로 최적화해서 정리하는걸로 하자

player에 그래비티가 적용안된듯



질문) 막 경력 3년이상 이런거는 신입은 아예 지원이안되는곳인지



